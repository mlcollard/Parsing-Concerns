<style>
*{
    font-weight : 900;
}
expr_stmt > expr[concern='parsing'], *[concern='parsing'] {
    color : red;
    font-weight : 900;
}
expr_stmt > expr[nonconcern='nonparsing'], *[nonconcern='nonparsing'] {
    color : black;
    font-weight : 900;
}
</style>
<pre>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:concern="https://mlcollard/net/concern" revision="1.0.0" language="C++"><comment type="block" nonconcern="nonparsing">/*
    srcfacts.cpp

    Produces a report with various measures of source code.
    Supports C++, C, Java, and C#. Input is an XML file in the srcML format,
    and output is a markdown table with the measures. Performance statistics
    are output to standard error.

    The code includes a complete XML parser:
    * Characters and content from XML is in UTF-8
    * DTD declarations are allowed, but not fine-grained parsed
    * No checking for well-formedness
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string_view&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;optional&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iomanip&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cmath&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;chrono&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bitset&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;archive.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;archive_entry.h&gt;</cpp:file></cpp:include>

<comment type="line">// provides literal string operator""sv</comment>
<using>using <namespace>namespace <name><name>std</name><operator>::</operator><name>literals</name><operator>::</operator><name>string_view_literals</name></name>;</namespace></using>

<decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name>int</name></type> <name>BLOCK_SIZE</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>
<decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name>int</name></type> <name>BUFFER_SIZE</name> <init>= <expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">16</literal> <operator>*</operator> <name>BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>

<decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>bitset</name><argument_list type="generic">&lt;<argument><expr><literal type="number">256</literal></expr></argument>&gt;</argument_list></name></type> <name>xmlNameMask</name><argument_list>(<argument><expr><literal type="string">"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"</literal>
                                   <literal type="string">"00000111111111111111111111111110100001111111111111111111111111100000001111111111011000000000000000000000000000000000000000000000"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt concern="parsing"><decl><type><specifier>constexpr</specifier> <name>auto</name></type> <name>WHITESPACE</name> <init>= <expr><literal type="string">" \n\t\r"</literal><name>sv</name></expr></init></decl>;</decl_stmt>
<decl_stmt concern="parsing"><decl><type><specifier>constexpr</specifier> <name>auto</name></type> <name>NAMEEND</name> <init>= <expr><literal type="string">"&gt; /\":=\n\t\r"</literal><name>sv</name></expr></init></decl>;</decl_stmt>

<decl_stmt concern="parsing"><decl><type><specifier>constexpr</specifier> <name>int</name></type> <name>XML_DELIMITER_SIZE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
    Refill the content preserving the existing data.

    @param[in, out] content View of the content
    @return Number of bytes read
    @retval 0 EOF
    @retval -1 Read error
*/</comment>
<function><attribute>[[<expr><name>nodiscard</name></expr>]]</attribute> <type><name>int</name></type> <name>refillContent</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>string_view</name></name><modifier>&amp;</modifier></type> <name>content</name></decl></parameter>)</parameter_list> <block>{<block_content>

    <comment type="line">// libarchive input setup</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>archive</name> <modifier>*</modifier></type><name>inputArchive</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inputArchive</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>inputArchive</name> <operator>=</operator> <call><name>archive_read_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>archive_read_support_format_all</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>archive_read_support_filter_all</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>archive_read_support_format_raw</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>archive_read_support_format_empty</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>archive_read_open_fd</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>status</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"input error: Invalid data in standard input\n"</literal></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>archive_entry</name><modifier>*</modifier></type> <name>inputEntry</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inputEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>status</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"input error: Invalid data in standard input header\n"</literal></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// internal buffer for reading from the input archive</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><name>BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="line">// preserve prefix of unprocessed characters to start of the buffer</comment>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>copy</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>content</name><operator>.</operator><name>cend</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// read the next block</comment>
    <decl_stmt><decl><type><name>auto</name></type> <name>bytesRead</name> <init>= <expr><call><name>archive_read_data</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BUFFER_SIZE</name> <operator>-</operator> <name>BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* ERROR */</comment>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// EOF</comment>
    <if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>archive_read_free</name><argument_list>(<argument><expr><name>inputArchive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// set content to the start of the buffer</comment>
    <expr_stmt><expr><name>content</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>string_view</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>bytesRead</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// trace parsing</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TRACE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>std::clog &lt;&lt; "\033[1m" &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; m &lt;&lt; "\u001b[0m" &lt;&lt; '\t'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE0</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE1</name><parameter_list>(<parameter><type><name>l1</name></type></parameter>, <parameter><type><name>n1</name></type></parameter>)</parameter_list></cpp:macro>                         <cpp:value>"\033[1m" &lt;&lt; l1 &lt;&lt; "\u001b[0m" &lt;&lt; "|" &lt;&lt; "\u001b[31;1m" &lt;&lt; n1 &lt;&lt; "\u001b[0m" &lt;&lt; "| "</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE2</name><parameter_list>(<parameter><type><name>l1</name></type></parameter>, <parameter><type><name>n1</name></type></parameter>, <parameter><type><name>l2</name></type></parameter>, <parameter><type><name>n2</name></type></parameter>)</parameter_list></cpp:macro>                 <cpp:value>TRACE1(l1,n1)             &lt;&lt; TRACE1(l2,n2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE3</name><parameter_list>(<parameter><type><name>l1</name></type></parameter>, <parameter><type><name>n1</name></type></parameter>, <parameter><type><name>l2</name></type></parameter>, <parameter><type><name>n2</name></type></parameter>, <parameter><type><name>l3</name></type></parameter>, <parameter><type><name>n3</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>TRACE2(l1,n1,l2,n2)       &lt;&lt; TRACE1(l3,n3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE4</name><parameter_list>(<parameter><type><name>l1</name></type></parameter>, <parameter><type><name>n1</name></type></parameter>, <parameter><type><name>l2</name></type></parameter>, <parameter><type><name>n2</name></type></parameter>, <parameter><type><name>l3</name></type></parameter>, <parameter><type><name>n3</name></type></parameter>, <parameter><type><name>l4</name></type></parameter>, <parameter><type><name>n4</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TRACE3(l1,n1,l2,n2,l3,n3) &lt;&lt; TRACE1(l4,n4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_TRACE</name><parameter_list>(<parameter><type><name>_2</name></type></parameter>,<parameter><type><name>_3</name></type></parameter>,<parameter><type><name>_4</name></type></parameter>,<parameter><type><name>_5</name></type></parameter>,<parameter><type><name>_6</name></type></parameter>,<parameter><type><name>_7</name></type></parameter>,<parameter><type><name>_8</name></type></parameter>,<parameter><type><name>_9</name></type></parameter>,<parameter><type><name>NAME</name></type></parameter>,<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NAME</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>m</name></type></parameter>,<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HEADER(m) &lt;&lt; GET_TRACE(__VA_ARGS__, TRACE4, _UNUSED, TRACE3, _UNUSED, TRACE2, _UNUSED, TRACE1, TRACE0, TRACE0)(__VA_ARGS__) &lt;&lt; '\n';</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter> <comment type="block">/* argc */</comment>, <parameter><decl><type><name><name>char</name><modifier>*</modifier> <comment type="block">/* argv */</comment><index>[]</index></name></type></decl></parameter>)</parameter_list> <block>{<block_content>

    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>startTime</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>steady_clock</name><operator>::</operator><name>now</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>url</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>textSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>exprCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>functionCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>classCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>unitCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>declCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>commentCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>totalBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>content</name></decl>;</decl_stmt>
    <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"START DOCUMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>bytesRead</name> <init>= <expr><call><name>refillContent</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: File input error\n"</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Empty file\n"</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt concern="parsing"><expr><name>totalBytes</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// parse XML declaration</comment>
        <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;?xml "</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;?xml "</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;?xml"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// parse required version</comment>
        <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><literal type="string">"= "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>attr</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"="</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name>char</name></type> <name>delimiter</name> <init>= <expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>delimiter</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>delimiter</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid start delimiter for version in XML declaration\n"</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>valueEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>valueEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid end delimiter for version in XML declaration\n"</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>attr</name> <operator>!=</operator> <literal type="string">"version"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
            <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Missing required first attribute version in XML declaration\n"</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>version</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// parse optional encoding and standalone attributes</comment>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>optional</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string_view</name></name></expr></argument>&gt;</argument_list></name></type> <name>encoding</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>optional</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>string_view</name></name></expr></argument>&gt;</argument_list></name></type> <name>standalone</name></decl>;</decl_stmt>
        <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><literal type="string">"= "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete attribute in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>attr2</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"="</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"="</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"="</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name>char</name></type> <name>delimiter2</name> <init>= <expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>delimiter2</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>delimiter2</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid start delimiter for attribute "</literal> <operator>&lt;&lt;</operator> <name>attr2</name> <operator>&lt;&lt;</operator> <literal type="string">" in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>valueEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>delimiter2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>valueEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete attribute "</literal> <operator>&lt;&lt;</operator> <name>attr2</name> <operator>&lt;&lt;</operator> <literal type="string">" in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><name>attr2</name> <operator>==</operator> <literal type="string">"encoding"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>encoding</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>attr2</name> <operator>==</operator> <literal type="string">"standalone"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>standalone</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid attribute "</literal> <operator>&lt;&lt;</operator> <name>attr2</name> <operator>&lt;&lt;</operator> <literal type="string">" in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>valueEndPosition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><literal type="string">"= "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete attribute in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>attr2</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"="</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name>char</name></type> <name>delimiter2</name> <init>= <expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>delimiter2</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>delimiter2</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid start delimiter for attribute "</literal> <operator>&lt;&lt;</operator> <name>attr2</name> <operator>&lt;&lt;</operator> <literal type="string">" in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>valueEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>delimiter2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>valueEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete attribute "</literal> <operator>&lt;&lt;</operator> <name>attr2</name> <operator>&lt;&lt;</operator> <literal type="string">" in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><operator>!</operator><name>standalone</name> <operator>&amp;&amp;</operator> <name>attr2</name> <operator>==</operator> <literal type="string">"standalone"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>standalone</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid attribute "</literal> <operator>&lt;&lt;</operator> <name>attr2</name> <operator>&lt;&lt;</operator> <literal type="string">" in XML declaration\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
            <comment type="line">// assert(content[valueEndPosition + 1] == '"');</comment>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>valueEndPosition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"XML DECLARATION"</literal></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>encoding</name></expr> ?</condition><then> <expr><operator>*</operator><name>encoding</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"standalone"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>standalone</name></expr> ?</condition><then> <expr><operator>*</operator><name>standalone</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"?&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'O'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'C'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'T'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'Y'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// parse DOCTYPE</comment>
        <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;!DOCTYPE "</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;!DOCTYPE "</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;!DOCTYPE"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>depthAngleBrackets</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt concern="parsing"><decl><type><name>bool</name></type> <name>inSingleQuote</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt concern="parsing"><decl><type><name>bool</name></type> <name>inDoubleQuote</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt concern="parsing"><decl><type><name>bool</name></type> <name>inComment</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <while>while <condition concern="parsing">(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><literal type="string">"&lt;&gt;'\"-"</literal><name>sv</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>inComment</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>p</name> <operator>+=</operator> <literal type="string">"&lt;!--"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"--&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"--&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>inComment</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>p</name> <operator>+=</operator> <literal type="string">"--&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><name>inComment</name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>p</name></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>inSingleQuote</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inDoubleQuote</name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><operator>++</operator><name>depthAngleBrackets</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>p</name></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>inSingleQuote</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inDoubleQuote</name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><operator>--</operator><name>depthAngleBrackets</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>p</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>inSingleQuote</name> <operator>=</operator> <operator>!</operator><name>inSingleQuote</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>p</name></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>inDoubleQuote</name> <operator>=</operator> <operator>!</operator><name>inDoubleQuote</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><name>depthAngleBrackets</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt concern="parsing"><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <decl_stmt concern="parsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>contents</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"DOCTYPE"</literal></expr></argument>, <argument><expr><literal type="string">"contents"</literal></expr></argument>, <argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt concern="parsing"><decl><type><name>bool</name></type> <name>doneReading</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>doneReading</name></expr>)</condition> <block>{<block_content>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><call><name><name>content</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>BLOCK_SIZE</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// refill content preserving unprocessed</comment>
            <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>bytesRead</name> <init>= <expr><call><name>refillContent</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: File input error\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>doneReading</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt concern="parsing"><expr><name>totalBytes</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt nonconcern="nonparsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// parse character entity references</comment>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>unescapedCharacter</name></decl>;</decl_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>escapedCharacter</name></decl>;</decl_stmt>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>unescapedCharacter</name> <operator>=</operator> <literal type="string">"&lt;"</literal></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>escapedCharacter</name> <operator>=</operator> <literal type="string">"&amp;lt;"</literal><name>sv</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>unescapedCharacter</name> <operator>=</operator> <literal type="string">"&gt;"</literal></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>escapedCharacter</name> <operator>=</operator> <literal type="string">"&amp;gt;"</literal><name>sv</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>unescapedCharacter</name> <operator>=</operator> <literal type="string">"&amp;"</literal></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>escapedCharacter</name> <operator>=</operator> <literal type="string">"&amp;amp;"</literal><name>sv</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>unescapedCharacter</name> <operator>=</operator> <literal type="string">"&amp;"</literal></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>escapedCharacter</name> <operator>=</operator> <literal type="string">"&amp;"</literal><name>sv</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>escapedCharacter</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>escapedCharacter</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>escapedCharacter</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>characters</name><argument_list>(<argument><expr><name>unescapedCharacter</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"CHARACTERS"</literal></expr></argument>, <argument><expr><literal type="string">"characters"</literal></expr></argument>, <argument><expr><name>characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>textSize</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// parse character non-entity references</comment>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>characterEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><literal type="string">"&lt;&amp;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>characters</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>characterEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"CHARACTERS"</literal></expr></argument>, <argument><expr><literal type="string">"characters"</literal></expr></argument>, <argument><expr><name>characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>loc</name> <operator>+=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>characters</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>characters</name><operator>.</operator><name>cend</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></cast></expr>;</expr_stmt>
            <expr_stmt><expr><name>textSize</name> <operator>+=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>characters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>characters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <comment type="block">/* &amp;&amp; content[0] == '&lt;' */</comment> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// parse XML comment</comment>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;!--"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>tagEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"--&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// refill content preserving unprocessed</comment>
                <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>bytesRead</name> <init>= <expr><call><name>refillContent</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: File input error\n"</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <if_stmt concern="parsing"><if>if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt concern="parsing"><expr><name>doneReading</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt concern="parsing"><expr><name>totalBytes</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>tagEndPosition</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"--&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Unterminated XML comment\n"</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>comment</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><literal type="string">"content"</literal></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"--&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <comment type="block">/* &amp;&amp; content[0] == '&lt;' */</comment> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'C'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal> <operator>&amp;&amp;</operator>
                   <name><name>content</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'T'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// parse CDATA</comment>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;![CDATA["</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>tagEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"]]&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <comment type="line">// refill content preserving unprocessed</comment>
                <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>bytesRead</name> <init>= <expr><call><name>refillContent</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: File input error\n"</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <if_stmt concern="parsing"><if>if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt concern="parsing"><expr><name>doneReading</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt concern="parsing"><expr><name>totalBytes</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>tagEndPosition</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"]]&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Unterminated CDATA\n"</literal></expr>;</expr_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>characters</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"CDATA"</literal></expr></argument>, <argument><expr><literal type="string">"characters"</literal></expr></argument>, <argument><expr><name>characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>textSize</name> <operator>+=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>characters</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr>;</expr_stmt>
            <expr_stmt><expr><name>loc</name> <operator>+=</operator> <cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>characters</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>characters</name><operator>.</operator><name>cend</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></cast></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"]]&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr> <comment type="block">/* &amp;&amp; content[0] == '&lt;' */</comment>)</condition> <block>{<block_content>
            <comment type="line">// parse processing instruction</comment>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;?"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;?"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;?"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>tagEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"?&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete processing instruction\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Unterminated processing instruction\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>target</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>data</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>, <argument><expr><name>tagEndPosition</name> <operator>-</operator> <name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"PI"</literal></expr></argument>, <argument><expr><literal type="string">"target"</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"data"</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"?&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"?&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> <comment type="block">/* &amp;&amp; content[0] == '&lt;' */</comment>)</condition> <block>{<block_content>
            <comment type="line">// parse end tag</comment>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;/"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;/"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;/"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid end tag name\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Unterminated end tag '"</literal> <operator>&lt;&lt;</operator> <call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"'\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><name>size_t</name></type> <name>colonPosition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>nameEndPosition</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>colonPosition</name> <operator>=</operator> <name>nameEndPosition</name></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>nameEndPosition</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>, <argument><expr><name>nameEndPosition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt nonconcern="nonparsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>qName</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><call><name><name>qName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid end tag element name\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>prefix</name><argument_list>(<argument><expr><call><name><name>qName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>colonPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>localName</name><argument_list>(<argument><expr><call><name><name>qName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>colonPosition</name></expr> ?</condition><then> <expr><name>colonPosition</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"END TAG"</literal></expr></argument>, <argument><expr><literal type="string">"qName"</literal></expr></argument>, <argument><expr><name>qName</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"localName"</literal></expr></argument>, <argument><expr><name>localName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// parse start tag</comment>
            <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid start tag name\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Unterminated start tag '"</literal> <operator>&lt;&lt;</operator> <call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"'\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt concern="parsing"><decl><type><name>size_t</name></type> <name>colonPosition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>nameEndPosition</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>colonPosition</name> <operator>=</operator> <name>nameEndPosition</name></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><name>nameEndPosition</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>, <argument><expr><name>nameEndPosition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt nonconcern="nonparsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>qName</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><call><name><name>qName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid start tag element name\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <decl_stmt nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>prefix</name><argument_list>(<argument><expr><call><name><name>qName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>colonPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt nonconcern="nonparsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>localName</name><argument_list>(<argument><expr><call><name><name>qName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>colonPosition</name></expr> ?</condition><then> <expr><name>colonPosition</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"START TAG"</literal></expr></argument>, <argument><expr><literal type="string">"qName"</literal></expr></argument>, <argument><expr><name>qName</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"localName"</literal></expr></argument>, <argument><expr><name>localName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>inEscape</name> <init>= <expr><name>localName</name> <operator>==</operator> <literal type="string">"escape"</literal><name>sv</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"expr"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>exprCount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"decl"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>declCount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"comment"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>commentCount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"function"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>functionCount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"unit"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>unitCount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"class"</literal><name>sv</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>classCount</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition concern="parsing">(<expr><name><name>xmlNameMask</name><index>[<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <if_stmt concern="parsing" nonconcern="nonparsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>content</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name><name>content</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                    <comment type="line">// parse XML namespace</comment>
                    <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"xmlns"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"xmlns"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"xmlns"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete namespace\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>prefixSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">":"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt concern="parsing"><expr><operator>--</operator><name>nameEndPosition</name></expr>;</expr_stmt>
                        <expr_stmt concern="parsing"><expr><name>prefixSize</name> <operator>=</operator> <name>nameEndPosition</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>prefix</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>prefixSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"="</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><call><name><name>content</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete namespace\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name>char</name></type> <name>delimiter</name> <init>= <expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>delimiter</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>delimiter</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete namespace\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>valueEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>valueEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Incomplete namespace\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>uri</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"NAMESPACE"</literal></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"uri"</literal></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>, <argument><expr><literal type="string">"\""</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <comment type="line">// parse attribute</comment>
                    <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>nameEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>nameEndPosition</name> <operator>==</operator> <call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Empty attribute name\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt concern="parsing"><decl><type><name>size_t</name></type> <name>colonPosition</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><name>nameEndPosition</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name>colonPosition</name> <operator>=</operator> <name>nameEndPosition</name></expr>;</expr_stmt>
                        <expr_stmt concern="parsing"><expr><name>nameEndPosition</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><name>NAMEEND</name></expr></argument>, <argument><expr><name>nameEndPosition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt nonconcern="nonparsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>qName</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>prefix</name><argument_list>(<argument><expr><call><name><name>qName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>colonPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <decl_stmt nonconcern="nonparsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>localName</name><argument_list>(<argument><expr><call><name><name>qName</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>colonPosition</name></expr> ?</condition><then> <expr><name>colonPosition</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>nameEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><call><name><name>content</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Attribute "</literal> <operator>&lt;&lt;</operator> <name>qName</name> <operator>&lt;&lt;</operator> <literal type="string">" is incomplete\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Attribute "</literal> <operator>&lt;&lt;</operator> <name>qName</name> <operator>&lt;&lt;</operator> <literal type="string">" missing =\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"="</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt concern="parsing"><decl><type><specifier>const</specifier> <name>char</name></type> <name>delimiter</name> <init>= <expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>delimiter</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>delimiter</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Attribute "</literal> <operator>&lt;&lt;</operator> <name>qName</name> <operator>&lt;&lt;</operator> <literal type="string">" missing start delimiter\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>valueEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>valueEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Attribute "</literal> <operator>&lt;&lt;</operator> <name>qName</name> <operator>&lt;&lt;</operator> <literal type="string">" missing end delimiter\n"</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="number">1</literal></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                    <decl_stmt nonconcern="nonparsing"><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>value</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <if_stmt><if nonconcern="nonparsing">if <condition>(<expr><name>localName</name> <operator>==</operator> <literal type="string">"url"</literal><name>sv</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt concern="parsing" nonconcern="nonparsing"><expr><name>url</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"ATTRIBUTE"</literal></expr></argument>, <argument><expr><literal type="string">"qName"</literal></expr></argument>, <argument><expr><name>qName</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"localName"</literal></expr></argument>, <argument><expr><name>localName</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line" nonconcern="nonparsing">// convert special srcML escaped element to characters</comment>
                    <if_stmt nonconcern="nonparsing"><if>if <condition>(<expr><name>inEscape</name> <operator>&amp;&amp;</operator> <name>localName</name> <operator>==</operator> <literal type="string">"char"</literal><name>sv</name></expr> <comment type="block">/* &amp;&amp; inUnit */</comment>)</condition> <block>{<block_content>
                        <comment type="line">// use strtol() instead of atoi() since strtol() understands hex encoding of '0x0?'</comment>
                        <decl_stmt concern="parsing" nonconcern="nonparsing"><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><name>char</name></type> <name>escapeValue</name> <init>= <expr><operator>(</operator><name>char</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>valueEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>XML_DELIMITER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
            <if_stmt concern="parsing"><if>if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition concern="parsing">(<expr><name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"/&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"/&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"/&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"END TAG"</literal></expr></argument>, <argument><expr><literal type="string">"qName"</literal></expr></argument>, <argument><expr><name>qName</name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"localName"</literal></expr></argument>, <argument><expr><name>localName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt concern="parsing"><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Invalid XML document\n"</literal></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><ternary><condition concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr> ?</condition><then> <expr><call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition concern="parsing">(<expr><operator>!</operator><call><name><name>content</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>content</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
        <comment type="line">// parse XML comment</comment>
        <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;!--"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"&lt;!--"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt concern="parsing"><decl><type><name><name>std</name><operator>::</operator><name>size_t</name></name></type> <name>tagEndPosition</name> <init>= <expr><call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"--&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
            <comment type="line">// refill content preserving unprocessed</comment>
            <decl_stmt concern="parsing"><decl><type><name>int</name></type> <name>bytesRead</name> <init>= <expr><call><name>refillContent</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: File input error\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <if_stmt concern="parsing"><if>if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name>doneReading</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt concern="parsing"><expr><name>totalBytes</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
            <expr_stmt concern="parsing"><expr><name>tagEndPosition</name> <operator>=</operator> <call><name><name>content</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="string">"--&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt concern="parsing" nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><name>tagEndPosition</name> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Unterminated XML comment\n"</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><attribute>[[<expr><name>maybe_unused</name></expr>]]</attribute> <type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name>string_view</name></name></type> <name>comment</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><literal type="string">"content"</literal></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><name>tagEndPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>content</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"--&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"--&gt;"</literal><name>sv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><literal type="string">"--&gt;"</literal><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>remove_prefix</name></name><argument_list>(<argument><expr><ternary><condition concern="parsing"><expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>content</name><operator>.</operator><name>npos</name></name></expr> ?</condition><then> <expr><call><name><name>content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>content</name><operator>.</operator><name>find_first_not_of</name></name><argument_list>(<argument><expr><name>WHITESPACE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt nonconcern="nonparsing"><if concern="parsing">if <condition concern="parsing">(<expr><operator>!</operator><call><name><name>content</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt concern="parsing"><expr><name><name>std</name><operator>::</operator><name>cerr</name></name> <operator>&lt;&lt;</operator> <literal type="string">"parser error: Extra content at end of document\n"</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt nonconcern="nonparsing"><expr><call><name>TRACE</name><argument_list>(<argument><expr><literal type="string">"END DOCUMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>finishTime</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>steady_clock</name><operator>::</operator><name>now</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>elapsedSeconds</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>duration_cast</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>chrono</name><operator>::</operator><name>duration</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>finishTime</name> <operator>-</operator> <name>startTime</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>MLOCPerSecond</name> <init>= <expr><name>loc</name> <operator>/</operator> <name>elapsedSeconds</name> <operator>/</operator> <literal type="number">1000000</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>files</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><name>unitCount</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>cout</name><operator>.</operator><name>imbue</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>locale</name></name><argument_list>{<argument><expr><literal type="string">""</literal></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>valueWidth</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>max</name></name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name>log10</name><argument_list>(<argument><expr><name>totalBytes</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1.3</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></cast></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt nonconcern="nonparsing"><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"# srcfacts: "</literal> <operator>&lt;&lt;</operator> <name>url</name> <operator>&lt;&lt;</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Measure      | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"Value |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"|:-------------|-"</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setfill</name></name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">":|\n"</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setfill</name></name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Characters   | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>textSize</name>      <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| LOC          | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>loc</name>           <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Files        | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>files</name>         <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Classes      | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>classCount</name>    <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Functions    | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>functionCount</name> <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Declarations | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>declCount</name>     <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Expressions  | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>exprCount</name>     <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>cout</name></name> <operator>&lt;&lt;</operator> <literal type="string">"| Comments     | "</literal> <operator>&lt;&lt;</operator> <call><name><name>std</name><operator>::</operator><name>setw</name></name><argument_list>(<argument><expr><name>valueWidth</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>commentCount</name>  <operator>&lt;&lt;</operator> <literal type="string">" |\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>cout</name><operator>.</operator><name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>clog</name><operator>.</operator><name>imbue</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>locale</name></name><argument_list>{<argument><expr><literal type="string">""</literal></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>clog</name><operator>.</operator><name>precision</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>clog</name></name> <operator>&lt;&lt;</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>clog</name></name> <operator>&lt;&lt;</operator> <name>totalBytes</name>  <operator>&lt;&lt;</operator> <literal type="string">" bytes\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>clog</name></name> <operator>&lt;&lt;</operator> <name>elapsedSeconds</name> <operator>&lt;&lt;</operator> <literal type="string">" sec\n"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>std</name><operator>::</operator><name>clog</name></name> <operator>&lt;&lt;</operator> <name>MLOCPerSecond</name> <operator>&lt;&lt;</operator> <literal type="string">" MLOC/sec\n"</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
</pre>
